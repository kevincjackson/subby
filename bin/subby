#!/usr/bin/env ruby

require 'optparse'

################################################################################
# Constants
################################################################################

EXECUTABLE_NAME = File.basename($PROGRAM_NAME)
BANNER = "Substitutes a string and its case variations.\n\n" +
         "Usage: #{EXECUTABLE_NAME} [options] string_in string_out\n\n"
CASES_IN = %w( camel class constant dash lower module sentence snake title underscore upper all )
CASES_OUT = %w( camel class constant dash lower module sentence snake title underscore upper match )
NUMBER_IN = %w( singular plural 1 2 all )
NUMBER_OUT = %w( singular plural 1 2 match )

################################################################################
# Parse options
################################################################################
options = {}
option_parser = OptionParser.new do |opts|

  opts.banner = BANNER

  opts.on("-c CASE_IN,...", "--case-in", Array,
    "limit cases to #{CASES_IN.join('|')}") do |ci|
    if ci.any? { |c| !CASES_IN.include? c }
      raise OptionParser::InvalidArgument
    else
      options[:case_in] = ci
    end
  end

  opts.on("--case-out CASE_OUT", CASES_OUT,
    "convert all incoming to CASE_OUT") do |co|
    options[:case_out] = co
  end

  opts.on("--number-in NUMBER_IN", NUMBER_IN,
    "limit processing to singular, or plural (1 or 2)") do |ni|
    options[:number_in] = ni
  end

  opts.on("--number-out NUMBER_OUT", NUMBER_OUT,
    "convert all incoming to NUMBER_OUT") do |no|
    options[:number_out] = no
  end

end

# Handle invalid options
begin
  option_parser.parse!
rescue OptionParser::InvalidArgument => ex
  STDERR.puts ex.message
  STDERR.puts
  STDERR.puts option_parser
  exit(1)
rescue OptionParser::InvalidOption => ex
  STDERR.puts ex.message
  STDERR.puts
  STDERR.puts option_parser
  exit(1)
end

################################################################################
# Parse arguments
################################################################################
if ARGV.count == 0
  STDERR.puts "Error: you must provide a string_in and a string_out\n\n"
  STDERR.puts option_parser.help
  exit(1)
elsif ARGV.count == 1
  STDERR.puts "Error: you must provide a string_out\n\n"
  STDERR.puts option_parser.help
  exit(1)
elsif ARGV.count == 2
  string_in = ARGV[0]
  string_out = ARGV[1]
else
  STDERR.puts "Error: expected 2 arguments, got #{ARGV.count}\n\n"
  STDERR.puts option_parser.help
  exit(1)
end

################################################################################
# IF NO FILE GET IT FROM TERMINAL
################################################################################
# Handle ^C
Signal.trap("SIGINT") do
  STDERR.puts
  exit 1
end

if STDIN.tty?
  # sed / tr style Read Eval Print Loop
  while true
    # Handle EOF
    if STDIN.eof?
     exit 0
    end
    file = STDIN.gets.chomp
    # TODO Launch
  end
################################################################################
# ELSE WE HAVE A FILE
################################################################################
else
    file = STDIN.read.chomp
    # TODO Launch command
end

DEBUG = false
if DEBUG
  puts "File"
  puts file

  puts "options"
  p options

  puts "args"
  puts string_in + " " + string_out
end
